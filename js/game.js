// Generated by CoffeeScript 1.6.3
(function() {
  var Asteroid, Bullet, Button, Drawable, Engine, Hud, Image, Screen, Text, Vessel, canvas, context, createAsteroidStore, createSurface, debug, directionOf, distanceBetween, enableLog, game, inDocumentConsole, keymap, log, oldLog, showconsole, speedOf, surface, translate, willCollide,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Number.prototype.toDeg = function() {
    return this * 180 / Math.PI;
  };

  Number.prototype.humanize = function(precision) {
    if (precision == null) {
      precision = 2;
    }
    return Math.round(this * Math.pow(10, precision)) / Math.pow(10, precision);
  };

  Array.prototype.remove = function() {
    var args, index, item, _i, _len, _results;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    _results = [];
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      item = args[_i];
      index = this.indexOf(item);
      if (!(index < 0)) {
        _results.push(this.splice(index, 1));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  debug = true;

  showconsole = false;

  enableLog = function(object, name) {
    var id, overload, prop;
    overload = function(instance, name) {
      var old,
        _this = this;
      old = instance[name];
      return instance[name] = function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        console.log("" + name + "(" + args + ")");
        return old.apply(instance, args);
      };
    };
    if (name != null) {
      overload(object, name);
    } else {
      for (id in object) {
        prop = object[id];
        if (typeof prop === 'function') {
          overload(object, id);
        }
      }
    }
    return true;
  };

  distanceBetween = function(pointA, pointB) {
    var refA, refB;
    refA = pointA.position || pointA;
    refB = pointB.position || pointB;
    return Math.sqrt(Math.pow(refA.x - refB.x, 2) + Math.pow(refA.y - refB.y, 2));
  };

  speedOf = function(object) {
    return Math.sqrt(Math.pow(object.vector.x, 2) + Math.pow(object.vector.y, 2));
  };

  directionOf = function(object) {
    return Math.atan2(object.vector.y, object.vector.x);
  };

  willCollide = function(objectA, objectB) {
    var futurePositionA, futurePositionB;
    futurePositionA = {
      x: objectA.position.x + objectA.vector.x,
      y: objectA.position.y + objectA.vector.y
    };
    futurePositionB = {
      x: objectB.position.x + objectB.vector.x,
      y: objectB.position.y + objectB.vector.y
    };
    return distanceBetween(futurePositionA, futurePositionB) <= (objectA.size + objectB.size) / 2;
  };

  log = function(text) {
    return console.log(text);
  };

  canvas = document.createElement('canvas');

  canvas.width = window.innerWidth;

  canvas.height = window.innerHeight;

  document.body.appendChild(canvas);

  context = canvas.getContext('2d');

  surface = null;

  if (showconsole) {
    canvas.width = window.innerWidth - 200;
    inDocumentConsole = document.createElement('div');
    inDocumentConsole.setAttribute('class', 'console');
    inDocumentConsole.append = function(text) {
      var element;
      element = document.createElement('p');
      element.innerText = text;
      return this.appendChild(element);
    };
    document.body.appendChild(inDocumentConsole);
    oldLog = console.log;
    console.log = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      inDocumentConsole.append.apply(inDocumentConsole, args);
      return oldLog.apply(console, args);
    };
  }

  log("Window is (" + window.innerWidth + ", " + window.innerHeight + ")");

  log("Canvas created with (" + canvas.width + ", " + canvas.height + ")");

  createSurface = function() {
    return surface = {
      width: 4000,
      height: 3000,
      context: context
    };
  };

  Drawable = (function() {
    function Drawable() {}

    Drawable.prototype.visible = true;

    Drawable.prototype.isInElement = function(x, y) {
      return (this.x <= x && x <= this.x + this.w) && (this.y <= y && y <= this.y + this.h);
    };

    Drawable.prototype.drawFrom = function(x, y) {
      if (this.visible) {
        if (typeof this.drawElement === "function") {
          this.drawElement(x, y);
        }
        return this.drawChildrenFrom(this.x + x, this.y + y);
      }
    };

    Drawable.prototype.drawChildrenFrom = function(x, y) {
      var elem, id, _results;
      _results = [];
      for (id in this) {
        elem = this[id];
        _results.push(elem != null ? typeof elem.drawFrom === "function" ? elem.drawFrom(x, y) : void 0 : void 0);
      }
      return _results;
    };

    return Drawable;

  })();

  Text = (function(_super) {
    __extends(Text, _super);

    function Text(text, style, size, x, y) {
      this.text = text;
      this.style = style != null ? style : 'black';
      if (size == null) {
        size = 12;
      }
      this.x = x != null ? x : 0;
      this.y = y != null ? y : 0;
      this.font = "" + size + "px sans-serif";
    }

    Text.prototype.drawElement = function(x, y) {
      context.textBaseline = 'middle';
      context.textAlign = 'center';
      context.fillStyle = this.style;
      context.font = this.font;
      return context.fillText(this.text, this.x + x, this.y + y);
    };

    return Text;

  })(Drawable);

  Image = (function(_super) {
    __extends(Image, _super);

    function Image(x, y, url) {
      this.x = x;
      this.y = y;
      this.url = url;
      game.images[this.url] = null;
    }

    Image.prototype.drawElement = function(x, y) {
      if (game.images[this.url] != null) {
        return context.drawImage(game.images[this.url], this.x + x, this.y + y);
      }
    };

    return Image;

  })(Drawable);

  Button = (function(_super) {
    __extends(Button, _super);

    Button.prototype.color = '#0aa';

    Button.prototype.activecolor = '#088';

    Button.prototype.hovercolor = '#099';

    Button.prototype.getStateColor = function() {
      switch (this.state) {
        case 'active':
          return this.activecolor;
        case 'hover':
          return this.hovercolor;
        default:
          return this.color;
      }
    };

    function Button(x, y, w, h) {
      this.x = x;
      this.y = y;
      this.w = w;
      this.h = h;
      game.buttons.push(this);
    }

    Button.prototype.drawElement = function(x, y) {
      context.fillStyle = this.getStateColor();
      return context.fillRect(this.x + x, this.y + y, this.w, this.h);
    };

    Button.prototype.withText = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.content = (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(Text, args, function(){});
      this.content.x = this.w / 2;
      this.content.y = this.h / 2;
      return this;
    };

    Button.prototype.withImage = function(url) {
      this.content = new Image(0, 0, 'pause.png');
      return this;
    };

    return Button;

  })(Drawable);

  Screen = (function(_super) {
    __extends(Screen, _super);

    Screen.prototype.visible = false;

    function Screen(x, y, w, h, background) {
      this.x = x;
      this.y = y;
      this.w = w;
      this.h = h;
      this.background = background;
      this.text = new Text('Game paused', 'white', 48, canvas.width / 2, 280);
      this.resumeButton = new Button(canvas.width / 2 - 80, 320, 160, 40).withText('Resume...', '#fff', 28);
    }

    Screen.prototype.drawElement = function(x, y) {
      if (this.background != null) {
        context.fillStyle = this.background;
        context.fillRect(x + this.x, y + this.y, canvas.width, canvas.height);
      }
      return this.drawChildrenFrom(this.x + x, this.y + y);
    };

    Screen.prototype.draw = function() {
      return this.drawFrom(this.x, this.y);
    };

    return Screen;

  })(Drawable);

  Hud = (function(_super) {
    __extends(Hud, _super);

    Hud.prototype.x = 0;

    Hud.prototype.y = 0;

    Hud.prototype.w = canvas.width;

    Hud.prototype.h = canvas.height;

    Hud.prototype.visible = true;

    function Hud() {
      this.pauseScreen = new Screen(this.x, this.y, this.w, this.h, 'rgba(0,0,0,0.05)');
      this.pauseButton = new Button(canvas.width - 40, 10, 20, 20).withImage('pause.png');
      delete this.background;
    }

    return Hud;

  })(Screen);

  Asteroid = (function() {
    Asteroid.generate = function(size, facets) {
      var angle, closed, distance, firstPoint, initialAngle, point, points;
      initialAngle = (Math.random() + 3) * Math.PI / facets;
      angle = initialAngle;
      points = [];
      while (!closed) {
        if (angle - initialAngle >= 2 * Math.PI) {
          points.push(firstPoint);
          closed = true;
        } else {
          distance = (Math.random() + 4) * size / 10;
          point = {
            x: Math.cos(angle) * distance,
            y: Math.sin(angle) * distance
          };
          if (typeof firstPoint !== "undefined" && firstPoint !== null) {
            points.push(point);
          } else {
            firstPoint = point;
            points.push(point);
          }
        }
        angle += (Math.random() + 3) * Math.PI / facets;
      }
      return points;
    };

    Asteroid.createImage = function(vertices, size) {
      var image, tempCanvas, tempContext, url, vertex, _i, _j, _len, _len1, _ref, _ref1;
      tempCanvas = document.createElement('canvas');
      tempCanvas.width = size * 2;
      tempCanvas.height = size;
      tempContext = tempCanvas.getContext('2d');
      tempContext.translate(size / 2, size / 2);
      tempContext.beginPath();
      tempContext.fillStyle = '#ccc';
      tempContext.moveTo(vertices[0].x, vertices[0].y);
      _ref = vertices.slice(1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        vertex = _ref[_i];
        tempContext.lineTo(vertex.x, vertex.y);
      }
      tempContext.fill();
      tempContext.translate(size, 0);
      tempContext.beginPath();
      tempContext.fillStyle = '#333';
      tempContext.moveTo(vertices[0].x, vertices[0].y);
      _ref1 = vertices.slice(1);
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        vertex = _ref1[_j];
        tempContext.lineTo(vertex.x, vertex.y);
      }
      tempContext.fill();
      tempContext.getImageData(size * -.5, size * -.5, size, size);
      url = tempCanvas.toDataURL();
      image = new window.Image();
      image.src = url;
      return image;
    };

    function Asteroid(posX, posY, vector, size, mass) {
      if (posX == null) {
        posX = 100;
      }
      if (posY == null) {
        posY = 40;
      }
      this.vector = vector;
      this.size = size != null ? size : 40;
      this.mass = mass;
      if (this.mass == null) {
        this.mass = this.size;
      }
      if (this.vector == null) {
        this.vector = {
          x: 0,
          y: 0
        };
      }
      this.position = {
        x: posX,
        y: posY
      };
      this.vertices = Asteroid.generate(this.size, this.facets);
      this.image = Asteroid.createImage(this.vertices, this.size);
      this.resistance = this.mass;
    }

    Asteroid.prototype.speed = 1;

    Asteroid.prototype.facets = 32;

    Asteroid.prototype.direction = {
      x: 1,
      y: 0
    };

    Asteroid.prototype.position = {
      x: 100,
      y: 40
    };

    Asteroid.prototype.drawAt = function(x, y) {
      if (this.collides) {
        return context.drawImage(this.image, this.size, 0, this.size, this.size, x, y, this.size, this.size);
      } else {
        return context.drawImage(this.image, 0, 0, this.size, this.size, x, y, this.size, this.size);
      }
    };

    return Asteroid;

  })();

  createAsteroidStore = function() {
    var asteroids;
    asteroids = [];
    asteroids.create = function() {
      var args, asteroid;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      asteroid = (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(Asteroid, args, function(){});
      this.push(asteroid);
      return asteroid;
    };
    asteroids.randomFill = function() {
      var i, j, orientation, pos, speed, vector, _i, _j;
      for (i = _i = 0; _i < 16; i = ++_i) {
        for (j = _j = 0; _j < 12; j = ++_j) {
          if (!(!((i === 7 || i === 8) && (j === 5 || j === 6)))) {
            continue;
          }
          orientation = 2 * Math.random() * Math.PI;
          speed = Math.random() + 1;
          vector = {
            x: Math.cos(orientation) * speed,
            y: Math.sin(orientation) * speed
          };
          pos = {
            x: (i + Math.random()) * game.engine.surface.width / 16,
            y: (j + Math.random()) * game.engine.surface.height / 12
          };
          asteroids.create(pos.x, pos.y, vector);
        }
      }
      return asteroids;
    };
    return asteroids;
  };

  translate = function(rad, x, y) {
    return {
      x: Math.cos(rad) * x - Math.sin(rad) * y,
      y: Math.sin(rad) * x + Math.cos(rad) * y
    };
  };

  Vessel = (function() {
    function Vessel(x, y, mass) {
      this.mass = mass != null ? mass : 20;
      this.acceleration = .1;
      this.position = {
        x: x || surface.width / 2,
        y: y || surface.height / 2
      };
      this.rotationalSpeed = .1;
      this.orientation = 0;
      this.vector = {
        x: 0,
        y: 0
      };
      this.cooldown = 0;
    }

    Vessel.prototype.size = 20;

    Vessel.prototype.drawAt = function(x, y) {
      var point, points, t, _i, _j, _len, _len1, _ref;
      context.beginPath();
      context.fillStyle = this.collides ? '#0ff' : '#f00';
      points = [];
      points.push({
        x: 10,
        y: 0
      });
      points.push({
        x: -10,
        y: 10
      });
      points.push({
        x: -5,
        y: 0
      });
      points.push({
        x: -10,
        y: -10
      });
      points.push({
        x: 10,
        y: 0
      });
      for (_i = 0, _len = points.length; _i < _len; _i++) {
        point = points[_i];
        t = translate(this.orientation, point.x, point.y);
        point.x = t.x + this.position.x - x;
        point.y = t.y + this.position.y - y;
      }
      context.moveTo(points[0].x, points[0].y);
      _ref = points.slice(1);
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        point = _ref[_j];
        context.lineTo(point.x, point.y);
      }
      return context.fill();
    };

    Vessel.prototype.createBullet = function() {
      var position, vector;
      position = {
        x: Math.cos(this.orientation) * this.size / 2 + this.position.x,
        y: Math.sin(this.orientation) * this.size / 2 + this.position.y
      };
      vector = {
        x: Math.cos(vessel.orientation) * 5 + vessel.vector.x,
        y: Math.sin(vessel.orientation) * 5 + vessel.vector.y
      };
      return new Bullet(position, vector);
    };

    Vessel.prototype.distanceFrom = function(object) {
      return Math.sqrt(Math.pow(object.position.x - this.position.x, 2) + Math.pow(object.position.y - this.position.y, 2));
    };

    return Vessel;

  })();

  keymap = {
    37: 'left',
    38: 'thrust',
    39: 'right',
    40: 'reverse',
    27: 'escape',
    32: 'stop',
    17: 'shoot'
  };

  Engine = (function() {
    var enableCounters;

    function Engine() {
      this.update = __bind(this.update, this);
      this.play = __bind(this.play, this);
      this.pause = __bind(this.pause, this);
      this.draw = __bind(this.draw, this);
      this.mainLoop = __bind(this.mainLoop, this);
      var code, key, keyboard,
        _this = this;
      this.hud = new Hud();
      this.asteroids = createAsteroidStore();
      this.vessel = new Vessel();
      this.bullets = [];
      keyboard = {};
      for (code in keymap) {
        key = keymap[code];
        keyboard[key] = false;
      }
      this.keyboard = keyboard;
      this.collisions = [];
      this.viewport = (function() {
        var background, height, width, x, y;
        x = _this.surface.width / 2 - canvas.width / 2;
        y = _this.surface.height / 2 - canvas.height / 2;
        width = canvas.width;
        height = canvas.height;
        log("Viewport is at (" + x + ", " + y + ") with (" + width + ", " + height + ")");
        background = game.images['space.jpg'];
        return {
          x: x,
          y: y,
          width: width,
          height: height,
          draw: function() {
            var asteroid, bullet, drawnAt, xOffset, yOffset, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
            context.clearRect(0, 0, canvas.width, canvas.height);
            this.x = game.engine.vessel.position.x - canvas.width / 2;
            this.y = game.engine.vessel.position.y - canvas.height / 2;
            if (background.width < this.width + this.x) {
              xOffset = background.width - this.x;
            } else if (this.x < 0) {
              xOffset = -this.x;
            }
            if (background.height < this.height + this.y) {
              yOffset = background.height - this.y;
            } else if (this.y < 0) {
              yOffset = -this.y;
            }
            if ((xOffset != null) && (yOffset != null)) {
              context.drawImage(background, background.width - xOffset, background.height - yOffset, xOffset, yOffset, 0, 0, xOffset, yOffset);
              context.drawImage(background, 0, background.height - yOffset, this.width - xOffset, yOffset, xOffset, 0, this.width - xOffset, yOffset);
              context.drawImage(background, background.width - xOffset, 0, xOffset, this.height - yOffset, 0, yOffset, xOffset, this.height - yOffset);
              context.drawImage(background, 0, 0, this.width - xOffset, this.height - yOffset, xOffset, yOffset, this.width - xOffset, this.height - yOffset);
            } else if (xOffset != null) {
              context.drawImage(background, background.width - xOffset, this.y, xOffset, this.height, 0, 0, xOffset, this.height);
              context.drawImage(background, 0, this.y, this.width - xOffset, this.height, xOffset, 0, this.width - xOffset, this.height);
            } else if (yOffset != null) {
              context.drawImage(background, this.x, background.height - yOffset, this.width, yOffset, 0, 0, this.width, yOffset);
              context.drawImage(background, this.x, 0, this.width, this.height - yOffset, 0, yOffset, this.width, this.height - yOffset);
            } else {
              context.drawImage(background, this.x, this.y, this.width, this.height, 0, 0, this.width, this.height);
            }
            _ref = game.engine.asteroids;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              asteroid = _ref[_i];
              drawnAt = {
                x: asteroid.position.x - this.x - asteroid.size / 2,
                y: asteroid.position.y - this.y - asteroid.size / 2
              };
              if (drawnAt.x > surface.width) {
                drawnAt.x -= surface.width;
              }
              if (drawnAt.y > surface.height) {
                drawnAt.y -= surface.height;
              }
              if (drawnAt.x + surface.width < this.width) {
                drawnAt.x += surface.width;
              }
              if (drawnAt.y + surface.height < this.height) {
                drawnAt.y += surface.height;
              }
              if ((-asteroid.size <= (_ref1 = drawnAt.x) && _ref1 <= this.width) && (-asteroid.size <= (_ref2 = drawnAt.y) && _ref2 <= this.height)) {
                asteroid.drawAt(drawnAt.x, drawnAt.y);
              }
            }
            _ref3 = game.engine.bullets;
            for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
              bullet = _ref3[_j];
              drawnAt = {
                x: bullet.position.x - this.x,
                y: bullet.position.y - this.y
              };
              if (drawnAt.x > surface.width) {
                drawnAt.x -= surface.width;
              }
              if (drawnAt.y > surface.height) {
                drawnAt.y -= surface.height;
              }
              if (drawnAt.x + surface.width < this.width) {
                drawnAt.x += surface.width;
              }
              if (drawnAt.y + surface.height < this.height) {
                drawnAt.y += surface.height;
              }
              if ((0 <= (_ref4 = drawnAt.x) && _ref4 <= this.width) && (0 <= (_ref5 = drawnAt.y) && _ref5 <= this.height)) {
                bullet.drawAt(drawnAt.x, drawnAt.y);
              }
            }
            if (game.engine.debug != null) {
              context.beginPath();
              context.strokeStyle = 'red';
              context.lineWidth = 2;
              x = game.engine.debug.contactPoint.x - this.x;
              y = game.engine.debug.contactPoint.y - this.y;
              context.arc(x, y, 5, 0, 2 * Math.PI);
              context.fillText(game.engine.debug.angle, x, y);
              context.stroke();
            }
            game.engine.vessel.drawAt(this.x, this.y);
            return game.engine.hud.draw();
          }
        };
      })();
    }

    Engine.prototype.running = null;

    Engine.prototype.counters = {
      start: Date.now(),
      frames: 0,
      add: function() {
        var camera, collisions, countersElement, createCounter, drawTime, fps, lastUpdate, oldDraw, oldUpdate, ship, timing, updateTime,
          _this = this;
        timing = function() {
          return (typeof performance !== "undefined" && performance !== null ? typeof performance.now === "function" ? performance.now() : void 0 : void 0) || window.Date.now();
        };
        countersElement = document.createElement('div');
        countersElement.setAttribute('class', 'counters');
        createCounter = function(title) {
          var counter, counterValue;
          counter = document.createElement('p');
          counter.innerHTML = title + ': ';
          counterValue = document.createElement('span');
          counterValue.setAttribute('class', title.replace(' ', '-').toLowerCase());
          counter.appendChild(counterValue);
          countersElement.appendChild(counter);
          return counterValue;
        };
        fps = createCounter('FPS');
        updateTime = createCounter('Update');
        drawTime = createCounter('Draw');
        collisions = createCounter('Collisions');
        camera = createCounter('Camera');
        ship = createCounter('Ship');
        document.body.appendChild(countersElement);
        lastUpdate = timing();
        fps.lastFrameCount = 0;
        oldUpdate = game.engine.update;
        oldDraw = game.engine.draw;
        collisions.total = 0;
        game.engine.update = function() {
          var endUpdate, updateStart;
          updateStart = timing();
          oldUpdate();
          endUpdate = timing();
          if (endUpdate - lastUpdate > 250) {
            collisions.innerText = "" + game.engine.collisions.length + " (total: " + (collisions.total += game.engine.collisions.length) + ")";
            updateTime.innerText = (endUpdate - updateStart).humanize();
            camera.innerText = "" + (game.engine.viewport.x.humanize(0)) + ", " + (game.engine.viewport.y.humanize(0));
            ship.innerText = "" + (game.engine.vessel.position.x.humanize(0)) + ", " + (game.engine.vessel.position.y.humanize(0)) + ", " + (speedOf(game.engine.vessel).humanize()) + " px/tick (" + (game.engine.vessel.vector.x.humanize()) + ", " + (game.engine.vessel.vector.y.humanize()) + ")";
            return asteroids.innerText = game.engine.asteroids.length;
          }
        };
        return game.engine.draw = function() {
          var drawStart, endLoop;
          drawStart = timing();
          oldDraw();
          endLoop = timing();
          drawTime.innerHTML = Math.round(endLoop - drawStart);
          _this.frames++;
          if (endLoop - lastUpdate > 250) {
            fps.innerHTML = _this.fps = Math.round((_this.frames - fps.lastFrameCount) * 1000 / (endLoop - lastUpdate));
            lastUpdate = endLoop;
            return fps.lastFrameCount = _this.frames;
          }
        };
      }
    };

    Engine.prototype.cursor = {
      x: null,
      y: null
    };

    Engine.prototype.createVessel = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(Vessel, args, function(){});
    };

    Engine.prototype.surface = createSurface();

    Engine.prototype.mainLoop = function() {
      this.update();
      return this.draw();
    };

    Engine.prototype.draw = function() {
      return this.viewport.draw();
    };

    enableCounters = false;

    Engine.prototype.init = function() {
      var animFrame, recursive,
        _this = this;
      if (this.enableCounters) {
        this.counters.add();
      }
      animFrame = window.requestAnimationFrame;
      if (animFrame == null) {
        window.webkitRequestAnimationFrame;
      }
      if (animFrame == null) {
        window.mozRequestAnimationFrame;
      }
      if (animFrame == null) {
        window.oRequestAnimationFrame;
      }
      if (animFrame == null) {
        window.msRequestAnimationFrame;
      }
      if (animFrame != null) {
        recursive = function() {
          _this.mainLoop();
          return animFrame(recursive, canvas);
        };
        recursive();
      } else {
        setInterval(this.mainLoop, 1000 / 60);
      }
      document.onkeydown = function(e) {
        return _this.events.push({
          type: 'keydown',
          keyCode: e.keyCode,
          action: keymap[e.keyCode]
        });
      };
      document.onkeyup = function(e) {
        return _this.events.push({
          type: 'keyup',
          keyCode: e.keyCode,
          action: keymap[e.keyCode]
        });
      };
      canvas.onmousemove = function(e) {
        return _this.events.push({
          type: 'mousemove',
          x: e.offsetX,
          y: e.offsetY
        });
      };
      canvas.onmousedown = function(e) {
        return _this.events.push({
          type: 'mousedown',
          x: e.offsetX,
          y: e.offsetY
        });
      };
      canvas.onmouseup = function(e) {
        return _this.events.push({
          type: 'mouseup',
          x: e.offsetX,
          y: e.offsetY
        });
      };
      this.asteroids.randomFill();
      return this;
    };

    Engine.prototype.pause = function() {
      this.running = false;
      this.hud.pauseScreen.visible = true;
      return this.hud.pauseButton.visible = false;
    };

    Engine.prototype.play = function() {
      this.running = true;
      this.hud.pauseScreen.visible = false;
      return this.hud.pauseButton.visible = true;
    };

    Engine.prototype.isPaused = function() {
      return !this.running;
    };

    Engine.prototype.events = [];

    Engine.prototype.handleButton = function(button, whenActive) {
      if (button.isInElement(this.cursor.x, this.cursor.y)) {
        if (this.cursor.state === 'down') {
          return button.state = 'active';
        } else if (this.cursor.state === 'up' && button.state === 'active') {
          whenActive();
          return delete button.state;
        } else {
          return button.state = 'hover';
        }
      } else if (button.state === 'hover' || this.cursor.state === 'up') {
        return delete button.state;
      }
    };

    Engine.prototype.update = function() {
      var event;
      while (this.events.length > 0) {
        event = this.events.shift();
        switch (event.type) {
          case 'mousemove':
            this.cursor.x = event.x;
            this.cursor.y = event.y;
            break;
          case 'mousedown':
            this.cursor.state = 'down';
            this.cursor.x = event.x;
            this.cursor.y = event.y;
            break;
          case 'mouseup':
            this.cursor.state = 'up';
            this.cursor.x = event.x;
            this.cursor.y = event.y;
            break;
          case 'keydown':
            this.keyboard[event.action] = true;
            break;
          case 'keyup':
            this.keyboard[event.action] = false;
        }
        if (this.isPaused()) {
          if (this.keyboard.escape) {
            this.play();
          }
          this.handleButton(this.hud.pauseScreen.resumeButton, this.play);
        } else {
          if (this.keyboard.escape) {
            this.pause();
          }
          this.handleButton(this.hud.pauseButton, this.pause);
        }
        if (event.type === 'mouseup') {
          delete this.cursor.type;
        }
      }
      if (!this.isPaused()) {
        this.updateCollisions(this.vessel, this.asteroids);
        this.updateAsteroids();
        this.updatePositions(this.bullets);
        return this.updateVessel(this.vessel);
      }
    };

    Engine.prototype.updateCollisions = function(vessel, asteroids) {
      var alreadyExists, asteroid, bullet, collision, current, distance, firstpass, gap, id, newCollisions, secondAsteroid, source, sourceAngle, sourceGap, sourceRotatedSpeed, sourceSpeed, target, targetAngle, targetGap, targetRotatedSpeed, targetSpeed, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _o, _ref, _ref1, _ref2, _ref3;
      firstpass = [];
      for (id = _i = 0, _len = asteroids.length; _i < _len; id = ++_i) {
        asteroid = asteroids[id];
        if (willCollide(vessel, asteroid)) {
          firstpass.push({
            source: vessel,
            target: asteroid
          });
        }
        _ref = asteroids.slice(id + 1);
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          secondAsteroid = _ref[_j];
          if (willCollide(asteroid, secondAsteroid)) {
            firstpass.push({
              source: asteroid,
              target: secondAsteroid
            });
          }
        }
        _ref1 = this.bullets;
        for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
          bullet = _ref1[_k];
          if (willCollide(asteroid, bullet)) {
            firstpass.push({
              source: asteroid,
              target: bullet
            });
          }
        }
      }
      _ref2 = this.collisions;
      for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
        collision = _ref2[_l];
        collision.active = false;
        collision.source.collides = false;
        collision.target.collides = false;
      }
      newCollisions = [];
      for (_m = 0, _len4 = firstpass.length; _m < _len4; _m++) {
        current = firstpass[_m];
        alreadyExists = false;
        _ref3 = this.collisions;
        for (_n = 0, _len5 = _ref3.length; _n < _len5; _n++) {
          collision = _ref3[_n];
          if (current.source === collision.source && current.target === collision.target) {
            alreadyExists = true;
            collision.active = true;
          }
        }
        if (!alreadyExists) {
          newCollisions.push(current);
        }
      }
      this.collisions = (function() {
        var _len6, _o, _ref4, _results;
        _ref4 = this.collisions;
        _results = [];
        for (_o = 0, _len6 = _ref4.length; _o < _len6; _o++) {
          collision = _ref4[_o];
          if (!collision.active) {
            continue;
          }
          collision.source.collides = true;
          collision.target.collides = true;
          _results.push(collision);
        }
        return _results;
      }).call(this);
      for (_o = 0, _len6 = newCollisions.length; _o < _len6; _o++) {
        collision = newCollisions[_o];
        source = collision.source;
        target = collision.target;
        distance = distanceBetween(source, target);
        gap = distance - (source.size + target.size) / 2;
        sourceGap = speedOf(source) * gap / (speedOf(source) + speedOf(target));
        targetGap = speedOf(target) * gap / (speedOf(source) + speedOf(target));
        source.position.x += Math.cos(directionOf(source)) * sourceGap;
        source.position.y += Math.sin(directionOf(source)) * sourceGap;
        target.position.x += Math.cos(directionOf(target)) * targetGap;
        target.position.y += Math.sin(directionOf(target)) * targetGap;
        source.collides = true;
        target.collides = true;
        collision.contactPoint = {
          x: (source.position.x * target.size + target.position.x * source.size) / (source.size + target.size),
          y: (source.position.y * target.size + target.position.y * source.size) / (source.size + target.size)
        };
        collision.angle = Math.atan2(collision.contactPoint.y - source.position.y, collision.contactPoint.x - source.position.x);
        collision.active = true;
        sourceSpeed = speedOf(source);
        targetSpeed = speedOf(target);
        sourceAngle = Math.atan2(source.vector.y, source.vector.x);
        targetAngle = Math.atan2(target.vector.y, target.vector.x);
        game.engine.debug = collision;
        log("Collision: " + (sourceAngle.toDeg()) + ", " + (targetAngle.toDeg()) + ": " + (collision.angle.toDeg()));
        sourceRotatedSpeed = (sourceSpeed * Math.cos(sourceAngle - collision.angle) * (source.mass - target.mass) + 2 * target.mass * targetSpeed * Math.cos(targetAngle - collision.angle)) / (source.mass + target.mass);
        targetRotatedSpeed = (targetSpeed * Math.cos(targetAngle - collision.angle) * (target.mass - source.mass) + 2 * source.mass * sourceSpeed * Math.cos(sourceAngle - collision.angle)) / (source.mass + target.mass);
        source.vector.x = sourceRotatedSpeed * Math.cos(collision.angle) + sourceSpeed * Math.sin(sourceAngle - collision.angle) * Math.cos(collision.angle + 2 * Math.PI);
        source.vector.y = sourceRotatedSpeed * Math.sin(collision.angle) + sourceSpeed * Math.sin(sourceAngle - collision.angle) * Math.sin(collision.angle + 2 * Math.PI);
        target.vector.x = targetRotatedSpeed * Math.cos(collision.angle) + targetSpeed * Math.sin(targetAngle - collision.angle) * Math.cos(collision.angle + 2 * Math.PI);
        target.vector.y = targetRotatedSpeed * Math.sin(collision.angle) + targetSpeed * Math.sin(targetAngle - collision.angle) * Math.sin(collision.angle + 2 * Math.PI);
        if (target.damage != null) {
          source.resistance -= target.damage;
          collision.active = false;
          source.collides = false;
          this.bullets.splice(this.bullets.indexOf(target), 1);
          if (source.resistance <= 0) {
            this.asteroids.splice(this.asteroids.indexOf(source), 1);
          }
        }
        this.collisions.push(collision);
      }
      return this.collisions = (function() {
        var _len7, _p, _ref4, _results;
        _ref4 = this.collisions;
        _results = [];
        for (_p = 0, _len7 = _ref4.length; _p < _len7; _p++) {
          collision = _ref4[_p];
          if (collision.active) {
            _results.push(collision);
          }
        }
        return _results;
      }).call(this);
    };

    Engine.prototype.updateVessel = function(vessel) {
      var _ref, _ref1;
      vessel.position.x += vessel.vector.x;
      if (vessel.position.x > game.engine.surface.width) {
        vessel.position.x = 0;
      }
      if (vessel.position.x < 0) {
        vessel.position.x = game.engine.surface.width;
      }
      vessel.position.y += vessel.vector.y;
      if (vessel.position.y > game.engine.surface.height) {
        vessel.position.y = 0;
      }
      if (vessel.position.y < 0) {
        vessel.position.y = game.engine.surface.height;
      }
      vessel.thrust = this.keyboard['thrust'];
      if (vessel.thrust) {
        vessel.vector.x += Math.cos(vessel.orientation) * vessel.acceleration;
        vessel.vector.y += Math.sin(vessel.orientation) * vessel.acceleration;
      }
      if (this.keyboard.reverse) {
        vessel.vector.x -= Math.cos(vessel.orientation) * vessel.acceleration * .2;
        vessel.vector.y -= Math.sin(vessel.orientation) * vessel.acceleration * .2;
      }
      if (this.keyboard.stop) {
        if (vessel.vector.x > 0) {
          vessel.vector.x -= Math.min(vessel.acceleration * .2, vessel.vector.x * vessel.acceleration);
        } else {
          vessel.vector.x += Math.min(vessel.acceleration * .2, -vessel.vector.x * vessel.acceleration);
        }
        if (vessel.vector.y > 0) {
          vessel.vector.y -= Math.min(vessel.acceleration * .2, vessel.vector.y * vessel.acceleration);
        } else {
          vessel.vector.y += Math.min(vessel.acceleration * .2, -vessel.vector.y * vessel.acceleration);
        }
        if ((-.01 < (_ref = vessel.vector.x) && _ref < .01)) {
          vessel.vector.x = 0;
        }
        if ((-.01 < (_ref1 = vessel.vector.y) && _ref1 < .01)) {
          vessel.vector.y = 0;
        }
      }
      if (this.keyboard['left']) {
        vessel.orientation -= vessel.rotationalSpeed;
      }
      if (this.keyboard['right']) {
        vessel.orientation += vessel.rotationalSpeed;
      }
      vessel.orientation = vessel.orientation % (2 * Math.PI);
      vessel.cooldown--;
      if (this.keyboard.shoot && vessel.cooldown <= 0) {
        vessel.cooldown = 10;
        return this.bullets.push(vessel.createBullet());
      }
    };

    Engine.prototype.updateAsteroids = function() {
      return this.updatePositions(this.asteroids);
    };

    Engine.prototype.updatePositions = function(collection) {
      var item, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = collection.length; _i < _len; _i++) {
        item = collection[_i];
        item.position.x += item.vector.x;
        if (item.position.x > game.engine.surface.width) {
          item.position.x = 0;
        }
        if (item.position.x < 0) {
          item.position.x = game.engine.surface.width;
        }
        item.position.y += item.vector.y;
        if (item.position.y > game.engine.surface.height) {
          item.position.y = 0;
        }
        if (item.position.y < 0) {
          _results.push(item.position.y = game.engine.surface.height);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    return Engine;

  })();

  Bullet = (function() {
    function Bullet(position, vector, mass, size) {
      this.position = position;
      this.vector = vector;
      this.mass = mass != null ? mass : .1;
      this.size = size != null ? size : 10;
      this.damage = 100 * this.mass;
    }

    Bullet.prototype.drawAt = function(x, y) {
      context.beginPath();
      context.fillStyle = 'orange';
      context.arc(x, y, this.size / 2, 0, 2 * Math.PI);
      return context.fill();
    };

    return Bullet;

  })();

  window.game = game = {
    buttons: [],
    images: {
      'space.jpg': null
    },
    debug: debug,
    load: function() {
      var counter, loadImage, url, _results,
        _this = this;
      counter = 0;
      loadImage = function(url) {
        var image;
        image = new window.Image();
        image.src = "img/" + url;
        return image.onload = function() {
          var asteroid, _i, _len, _ref;
          _this.images[url] = image;
          counter--;
          if (counter === 0) {
            _this.engine = new Engine();
            _this.engine.enableCounters = true;
            _this.engine.init().play();
            window.vessel = game.engine.vessel;
            window.asteroids = game.engine.asteroids;
            if (true) {
              _ref = window.asteroids;
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                asteroid = _ref[_i];
                asteroids.pop();
              }
              asteroids.push(new Asteroid(1500, 1200, {
                x: 0,
                y: 0
              }, 100));
              asteroids.push(new Asteroid(2100, 1100, {
                x: 2,
                y: 2
              }, 10));
              asteroids.push(new Asteroid(1900, 1100, {
                x: -2,
                y: 2
              }, 10));
              asteroids.push(new Asteroid(1900, 900, {
                x: -2,
                y: -2
              }, 10));
              asteroids.push(new Asteroid(2100, 900, {
                x: 2,
                y: -2
              }, 10));
              asteroids.push(new Asteroid(2300, 1300, {
                x: -2,
                y: -2
              }, 100));
              asteroids.push(new Asteroid(1700, 1300, {
                x: 2,
                y: -2
              }, 100));
              asteroids.push(new Asteroid(1700, 700, {
                x: 2,
                y: 2
              }, 100));
              asteroids.push(new Asteroid(2300, 700, {
                x: -2,
                y: 2
              }, 100));
              return vessel.position = {
                x: 2000,
                y: 1000
              };
            }
          }
        };
      };
      _results = [];
      for (url in this.images) {
        counter++;
        _results.push(loadImage(url));
      }
      return _results;
    },
    reset: function() {
      return delete this.engine;
    }
  };

  window.Engine = Engine;

  window.Asteroid = Asteroid;

}).call(this);
