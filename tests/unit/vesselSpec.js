// Generated by CoffeeScript 1.6.3
(function() {
  describe('The vessel', function() {
    var engine, oldImage;
    engine = null;
    oldImage = null;
    beforeEach(function() {
      oldImage = window.Image;
      window.Image = ImageHelper;
      game.load();
      window.Image.loadAll();
      engine = game.engine;
      return engine.play();
    });
    afterEach(function() {
      return window.Image = oldImage;
    });
    it('when playing updates on game ticks', function() {
      spyOn(engine, 'updateVessel');
      engine.update();
      return expect(engine.updateVessel).toHaveBeenCalled();
    });
    it('does not update while paused', function() {
      spyOn(engine, 'updateVessel');
      engine.pause();
      engine.update();
      return expect(engine.updateVessel).not.toHaveBeenCalled();
    });
    it('exists', function() {
      return expect(engine.vessel).toBeDefined();
    });
    it('has an acceleration of .1px/s', function() {
      var vessel;
      vessel = engine.createVessel();
      return expect(vessel.acceleration).toBe(.1);
    });
    it('is stopped', function() {
      var vessel;
      vessel = engine.createVessel();
      return expect(vessel.vector).toBeEqualTo({
        x: 0,
        y: 0
      });
    });
    it('does NOT collide any asteroids', function() {
      engine.update();
      return expect(engine.collisions.length).toBe(0);
    });
    it('is in the center of the screen', function() {
      var vessel;
      vessel = engine.createVessel();
      expect(vessel.position.x).toBe(canvas.width / 2);
      return expect(vessel.position.y).toBe(canvas.height / 2);
    });
    it('moves horizontally when having speed', function() {
      var vessel, x, y;
      vessel = engine.createVessel();
      vessel.vector.x = 3;
      x = vessel.position.x;
      y = vessel.position.y;
      engine.updateVessel(vessel);
      expect(vessel.position.x).toBe(x + 3);
      expect(vessel.position.y).toBe(y);
      engine.updateVessel(vessel);
      expect(vessel.position.x).toBe(x + 6);
      return expect(vessel.position.y).toBe(y);
    });
    it('has an orientation of 0', function() {
      var vessel;
      vessel = engine.createVessel();
      return expect(vessel.orientation).toBe(0);
    });
    it('has a rotational speed of 0.1', function() {
      var vessel;
      vessel = engine.createVessel();
      return expect(vessel.rotationalSpeed).toBe(0.1);
    });
    describe('pressing the thrust key', function() {
      beforeEach(function() {
        engine.play();
        engine.events.push({
          type: 'keydown',
          action: 'thrust'
        });
        return engine.update();
      });
      it('thrusts the vessel', function() {
        return expect(engine.vessel.thrust).toBeTruthy();
      });
      return it('increases the x vector', function() {
        var oldVector, vessel;
        vessel = engine.createVessel();
        oldVector = {
          x: vessel.vector.x,
          y: vessel.vector.y
        };
        engine.updateVessel(vessel);
        return expect(vessel.vector).toBeEqualTo({
          x: oldVector.x + vessel.acceleration,
          y: oldVector.y
        });
      });
    });
    describe('pressing the left key', function() {
      var vessel;
      vessel = null;
      beforeEach(function() {
        vessel = engine.createVessel();
        engine.keyboard.left = true;
        return engine.keyboard.thrust = true;
      });
      it('turns the vessel', function() {
        engine.updateVessel(vessel);
        expect(vessel.vector).toBeEqualTo({
          x: .1,
          y: 0
        });
        return expect(vessel.orientation).toBe(-0.1);
      });
      return afterEach(function() {
        return engine.keyboard.left = false;
      });
    });
    describe('releasing the thrust', function() {
      var vessel;
      vessel = null;
      beforeEach(function() {
        engine.keyboard.thrust = true;
        return engine.update();
      });
      it('does not thrusts', function() {
        engine.keyboard.thrust = false;
        engine.update();
        return expect(engine.vessel.thrust).toBeFalsy();
      });
      return it('keeps its speed', function() {
        var oldSpeed;
        oldSpeed = engine.vessel.speed;
        engine.keyboard.thrust = false;
        engine.update();
        return expect(engine.vessel.speed).toBe(oldSpeed);
      });
    });
    describe('can tell its distance from an object', function() {
      var vessel;
      vessel = null;
      beforeEach(function() {
        return vessel = engine.createVessel();
      });
      it('as 0 when they are superposed', function() {
        var object;
        object = {
          position: vessel.position
        };
        return expect(vessel.distanceFrom(object)).toBe(0);
      });
      it('as 1 when object is at (+1, 0)', function() {
        var object;
        object = {
          position: {
            x: vessel.position.x + 1,
            y: vessel.position.y
          }
        };
        return expect(vessel.distanceFrom(object)).toBe(1);
      });
      it('as 3 when object is at (0, -3)', function() {
        var object;
        object = {
          position: {
            x: vessel.position.x,
            y: vessel.position.y - 3
          }
        };
        return expect(vessel.distanceFrom(object)).toBe(3);
      });
      return it('as 5 when object is at (-3, +4)', function() {
        var object;
        object = {
          position: {
            x: vessel.position.x - 3,
            y: vessel.position.y + 4
          }
        };
        return expect(vessel.distanceFrom(object)).toBe(5);
      });
    });
    return describe('collides', function() {
      beforeEach(function() {
        return engine.play();
      });
      return it('when it hits an asteroid', function() {
        var asteroid, vessel;
        vessel = engine.createVessel();
        asteroid = engine.asteroids.create(vessel.position.x, vessel.position.y);
        engine.update();
        return expect(engine.collisions.length).toBe(1);
      });
    });
  });

}).call(this);
