// Generated by CoffeeScript 1.6.2
(function() {
  define(['game'], function(game) {
    return describe('Collisions', function() {
      var asteroids, engine, vessel;

      vessel = null;
      asteroids = null;
      engine = null;
      beforeEach(function() {
        game.engine = engine = new Engine();
        engine.init();
        engine.play();
        vessel = engine.createVessel();
        return asteroids = [];
      });
      describe('on first pass', function() {
        it('should be empty when distances are high', function() {
          asteroids.push(new Asteroid(vessel.position.x + 100, vessel.position.y));
          asteroids.push(new Asteroid(vessel.position.x, vessel.position.y + 100));
          asteroids.push(new Asteroid(vessel.position.x - 80, vessel.position.y - 80));
          engine.updateCollisions(vessel, asteroids);
          return expect(engine.collisions.length).toBe(0);
        });
        it('should have any items closer than 30', function() {
          asteroids.push(new Asteroid(vessel.position.x + 25, vessel.position.y));
          asteroids.push(new Asteroid(vessel.position.x - 25, vessel.position.y));
          asteroids.push(new Asteroid(vessel.position.x, vessel.position.y + 40));
          engine.updateCollisions(vessel, asteroids);
          return expect(engine.collisions.length).toBe(2);
        });
        return it('should have a reference to the correct items', function() {
          asteroids.push(new Asteroid(vessel.position.x - 40, vessel.position.y));
          asteroids.push(new Asteroid(vessel.position.x + 10, vessel.position.y));
          engine.updateCollisions(vessel, asteroids);
          expect(engine.collisions[0].source).toBe(vessel);
          return expect(engine.collisions[0].target).toBe(asteroids[1]);
        });
      });
      describe('between asteroids', function() {
        it('can happen', function() {
          asteroids.push(new Asteroid(100, 100));
          asteroids.push(new Asteroid(120, 120));
          engine.updateCollisions(vessel, asteroids);
          return expect(engine.collisions.length).toBe(1);
        });
        return it('happens when on the surface limit', function() {
          asteroids.push(new Asteroid(10, 10));
          asteroids.push(new Asteroid(-10, -10));
          engine.updateCollisions(vessel, asteroids);
          return expect(engine.collisions.length).toBe(1);
        });
      });
      it('should be known as collided', function() {
        var asteroid;

        asteroids.push(asteroid = new Asteroid(vessel.position.x + 10, vessel.position.y + 10));
        engine.updateCollisions(vessel, asteroids);
        expect(vessel.collides).toBeTruthy();
        return expect(asteroid.collides).toBeTruthy();
      });
      it('should be resetted after a collision passes', function() {
        var asteroid;

        asteroids.push(asteroid = new Asteroid(vessel.position.x + 10, vessel.position.y + 10));
        engine.updateCollisions(vessel, asteroids);
        asteroid.position = {
          x: 100,
          y: 100
        };
        engine.updateCollisions(vessel, asteroids);
        expect(vessel.collides).toBeFalsy();
        return expect(asteroid.collides).toBeFalsy();
      });
      return describe('head on between asteroids', function() {
        it('should invert their X vector', function() {
          var first, second;

          asteroids.push(first = new Asteroid(80, 0, {
            x: 1,
            y: 0
          }));
          asteroids.push(second = new Asteroid(120, 0, {
            x: -1,
            y: 0
          }));
          engine.updateCollisions(vessel, asteroids);
          expect(engine.collisions.length).toBe(1);
          expect(first.vector.x).toBeCloseTo(-1);
          expect(first.vector.y).toBeCloseTo(0);
          expect(second.vector.x).toBeCloseTo(1);
          return expect(second.vector.y).toBeCloseTo(0);
        });
        it('should invert their Y vector', function() {
          var first, second;

          asteroids.push(first = new Asteroid(0, 80, {
            x: 0,
            y: 1
          }));
          asteroids.push(second = new Asteroid(0, 120, {
            x: 0,
            y: -1
          }));
          engine.updateCollisions(vessel, asteroids);
          expect(engine.collisions.length).toBe(1);
          expect(first.vector.x).toBeCloseTo(0);
          expect(first.vector.y).toBeCloseTo(-1);
          expect(second.vector.x).toBeCloseTo(0);
          return expect(second.vector.y).toBeCloseTo(1);
        });
        return it('at 45Â° should invert both vectors', function() {
          var first, second;

          asteroids.push(first = new Asteroid(90, 90, {
            x: 1,
            y: 1
          }));
          asteroids.push(second = new Asteroid(110, 110, {
            x: -1,
            y: -1
          }));
          engine.updateCollisions(vessel, asteroids);
          expect(engine.collisions.length).toBe(1);
          expect(first.vector.x).toBeCloseTo(-1);
          expect(first.vector.y).toBeCloseTo(-1);
          expect(second.vector.x).toBeCloseTo(1);
          return expect(second.vector.y).toBeCloseTo(1);
        });
      });
    });
  });

}).call(this);

/*
//@ sourceMappingURL=collisionsSpec.map
*/
